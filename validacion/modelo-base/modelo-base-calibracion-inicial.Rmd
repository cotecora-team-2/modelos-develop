---
title: "Calibración del ensemble"
author: "M. Anzarut, F. González, I. Meza, T. Ortiz"
date: "2/26/2021"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#devtools::install_github("cotecora-team-2/quickcountmx")
library(cmdstanr)
library(posterior)
library(tidyverse)
library(patchwork)
library(quickcountmx)
theme_set(theme_minimal())
cb_palette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", 
                "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

```{r}
datos_ent <- conteo_2018 %>% filter(NOMBRE_ESTADO == "NAYARIT") %>% 
  # usar estratificacion anterior por ahora
  mutate(estrato_df = as.numeric(factor(estrato))) %>% 
  select(CLAVE_CASILLA, AMLO, estrato_df, ln = LISTA_NOMINAL_CASILLA, componente = .fittedPC1) %>% 
  mutate(in_sample = 0, y_f = 0) %>% 
  mutate(ln = ifelse(ln == 0, 600, ln)) %>% 
  mutate(no_casilla = row_number())
sim_datos_lista <- list()
x <- datos_ent %>% 
  select(ln, componente) %>% 
  as.matrix()
x_f <- scale(x)
sim_datos_lista$x_f <- x_f
sim_datos_lista$N_f <- nrow(x_f)
sim_datos_lista$n_covariates_f <- ncol(x_f)
sim_datos_lista$n_strata_f <- datos_ent$estrato_df %>% unique %>% length()
sim_datos_lista$n_f <- datos_ent$ln
sim_datos_lista$stratum_f <- datos_ent$estrato_df
jsonlite::write_json(sim_datos_lista, "datos/datos_prueba.json")
```


```{r}
sim_datos <- jsonlite::read_json("./datos/datos_prueba.json", simplifyVector = TRUE)
parametros <- jsonlite::read_json("./datos/datos_inicial.json", simplifyVector = TRUE)
print(parametros)
#print(sim_datos)
```


```{r}
sim_ensemble_datos <- c(sim_datos, parametros)
ruta <- file.path("./stan/simular_ensemble_modelo.stan")
modelo_inicial <- cmdstan_model(ruta)
ensemble <- modelo_inicial$sample(
    data = sim_ensemble_datos,
    iter_sampling = 1000, iter_warmup = 0, 
    chains = 1,
    refresh = 100, seed = 4322,
    fixed_param = TRUE)
  
```

## Propiedades del ensemble

#### Resumen de porcentaje de voto de la lista nominal

```{r}
sims_ensemble_tbl <- ensemble$draws() %>% as_draws_df()
total_nominal <- sim_ensemble_datos$n_f %>% sum
votos_tbl <- sims_ensemble_tbl %>% select(.draw, y_out) %>% 
  mutate(prop_nominal = y_out / total_nominal)
qplot(sims_ensemble_tbl$y_out / total_nominal, binwidth = 0.025 )
```
```{r}
sims_casillas <- sims_ensemble_tbl %>% 
  nest(y_sim = contains("y_f_sim")) %>% 
  select(.draw, sigma, y_sim) %>% 
  mutate(y_sim = map(y_sim, 
                        function(x) { tibble(y_f = as.numeric(x), no_casilla = 1:ncol(x)) })) %>% 
  unnest(y_sim)
sims_casillas <- sims_casillas %>% left_join(datos_ent %>% select(no_casilla, estrato_df, ln)) 
sims_casillas
```
Resumen por estrato

```{r}
resumen_estratos <- sims_casillas %>% group_by(.draw, estrato_df) %>% 
  summarise(total_votos = sum(y_f), total_nominal = sum(ln)) %>% 
  mutate(prop_nominal = total_votos / total_nominal)
ggplot(resumen_estratos, aes(x = factor(estrato_df), y = prop_nominal)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.5)
```

## Ajuste de ensemble simulado

Calculamos el voto obtenido por cada candidato y checamos si recuperamos los
valores considerando el tamaño de muestra que utilizaremos


```{r}
ruta <- file.path("./stan/modelo.stan")
modelo <- cmdstan_model(ruta)
source("R/funciones_calibracion.R")
```

```{r}
num_draw <- 121
datos_muestra <- obtener_muestra(num_draw, frac = 0.15, seed = 1132)
datos_1 <- c(sim_ensemble_datos, datos_muestra)
```




```{r, message=FALSE, warning=FALSE}
ajuste <- modelo$sample(data = datos_1, 
                          seed = 2211,
                          iter_sampling = 250, iter_warmup = 500,
                          refresh = 250, 
                          chains = 4, 
                          adapt_delta = 0.99,
                          max_treedepth = 12,
                          parallel_chains = 4, 
                          show_messages = FALSE)
ajuste$summary(variables = c("beta_0", "beta", "beta_bn"))
```
```{r}
valores_sim <- sims_ensemble_tbl %>% as_tibble() %>% filter(.draw == num_draw) 
valores_sim
```

```{r}
ajuste$cmdstan_diagnose()
```


```{r}
y_sims <- ajuste$draws() %>% as_draws_df() %>% 
  as_tibble()
mean(y_sims$y_out)/sum(datos_ent$ln)
ggplot(y_sims, aes(x = y_out)) +
  geom_histogram() +
  geom_vline(xintercept = valores_sim$y_out, colour = "red")
```

## Calibración algorítmica

```{r, warning = FALSE, message = FALSE}
reajustar_ensemble <- FALSE
set.seed(8823)
if(reajustar_ensemble){
ajustes_ensemble <- 
  map(1:100, ~ ajustar_diagnosticos(.x, frac = 0.15,
        modelo = modelo, 
        datos = sim_ensemble_datos,
        params = sims_ensemble_tbl[.x, ] %>% as_tibble %>% select(y_out, beta_0),
        adapt_delta = 0.99, max_treedepth = 12,
        iter_warmup = 500, iter_sampling = 250)) %>% 
  bind_rows()
  write_rds(ajustes_ensemble, "salidas/ensemble_ajustes_in.rds")
} else {
  ajustes_ensemble <- read_rds("salidas/ensemble_ajustes_in.rds")
}
```

En algunas corridas obtuvimos problemas numéricos?

```{r}
map(ajustes_ensemble$diagnosticos, "stdout") %>% str_detect("no problems detected") %>% 
  table
```



Ahora checamos que recuperamos los parámetros apropiadamente:

```{r}
sbc_rank_sim <- ajustes_ensemble %>% select(sbc_rank) %>% unnest(cols = sbc_rank)
g_1 <- ggplot(sbc_rank_sim, aes(sample = y_out)) +
  geom_qq(distribution = stats::qunif) +
  geom_abline() +
  labs(subtitle = "y_out")
g_2 <- ggplot(sbc_rank_sim, aes(sample = beta_0)) +
  geom_qq(distribution = stats::qunif) +
  geom_abline() +
  labs(subtitle = "beta_0")
g_1 + g_2
```

## Calibración inferencial



```{r}
prior_sd <- sd(sims_ensemble_tbl$y_out)
variable <- "y_out"
calib_inf_tbl <- ajustes_ensemble %>%
  unnest(cols = (params)) %>% 
  mutate(post_media = map_dbl(resumen, ~filter(.x, variable=="y_out") %>% pull(mean)),
         post_sd = map_dbl(resumen, ~ filter(.x, variable == "y_out") %>% pull(sd))) %>% 
  mutate(z_score = (post_media - y_out) / post_sd) %>% 
  mutate(contraccion = 1 - (post_sd/prior_sd)^2)
```

```{r}
ggplot(calib_inf_tbl, aes(x = contraccion, y = z_score)) + geom_point(alpha = 0.5) +
  xlim(c(0, 1))
```

```{r}
calib_cv <- ajustes_ensemble %>%
  unnest(cols = (params)) %>% 
  mutate(post_media = map_dbl(resumen, ~filter(.x, variable=="y_out") %>% pull(mean)),
         post_sd = map_dbl(resumen, ~ filter(.x, variable == "y_out") %>% pull(sd))) %>% 
  mutate(coef_variacion_post = post_sd / post_media )
quantile(100 * calib_cv$coef_variacion_post, probs = c(0.01, 0.05, 0.5, 0.90, 0.99)) %>% 
  round(., 1)
```


